//source: https://www.youtube.com/watch?v=wSNwjyhEe8I
// По примеру ниже мы видим, что let a живет в тот момент, когда у нас задействована, исполняется функция one().
// То есть переменные внутри функции живут в тот момент, когда я вызываю или использую функцию в своих вычислениях.
function one() {
  let a = 8;
  return a * 12;
}
console.log(a);
console.log(one());

// Дилемма счётчика.
// Переменная внутри функции работает, пока функция вызвана. Когда функция прекращена, закончена, return,
// тогда переменная исчезает, мы не можем к ней обратиться. А нельзя ли схитрить и создать функцию, внутри
// которой мы объявим переменную и будем с ней работать? Оказывается, можно. И мы можем использовать эту
// особенность, что когда мы вызываем функцию, у нас создаются переменные внутри неё.
// Замыкание / Closure
function t1() {
  let a = 0;
  return function () {
    a = a + 1;
    return a;
  };
}
// Грубо говоря, в ООП есть такая штука, как приватные свойства. Это свойства, которые доступны только внутри
// объекта. Так вот. Если вы хотите такие свойства, чтобы никто их больше не мог изменить, кроме определенной
// функции, то вы делаете замыкание.

//По сути, вы создаете несколько экземпляров областей видимости.
